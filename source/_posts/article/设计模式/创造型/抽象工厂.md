---
title: 抽象工厂
tags: []
categories:
  - article
  - 设计模式
  - 创造型
date: 2021-03-12 00:00:00
---

## 抽象工厂模式（Abstract Factory）

### 结构

![picture 29](../../../../assets/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E9%80%A0%E5%9E%8B/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/d74a53c6f67c8633fca65dc51e73562af6d7c5f87ec6766762a3485105a9fe11.png)

### 目的

提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。

### 动机

考虑一个多种风格标准的 UI 包，为滚动条、弹出框、按钮等 UI 组件定义不同的外观和行为。为了保证风格的可移植性，一个应用不应该为他的前端界面硬编码固定风格的 UI 。为了做到一键换肤的效果，我们可以定义一个抽象的组件工厂类 `WidgetFactory` 类，这个类声明了一系列用来创建每一类基本组件的接口。每类窗口组件都有一个抽象类，由具体的子类实现了窗口组件的特定风格。这样接口的使用者不需要关心具体的 UI 风格，只要直接使用抽象组件类即可。

对于某一类风格的 UI 其组件是相互依赖的，如何创建相互依赖的组件呢？可以使用抽象工厂类的对应风格实现类，来创建对应风格的 UI 组件。用代码标识类似这种样子：

```JAVA
AbstractFactory factory = new SpecialFactory();
Window window = factory.createWindow(); // SpecialWindow
ScrollBar scrollBar = factory.createScrollBar(); // SpecialScrollBar
```

### 使用场景

- 系统要独立于他的产品（类）的创建、组合和表示
- 系统要由多个产品系列中的一个来配置
- 要强调一系列相关的产品对象的设计以便联合使用
- 提供一个产品类库，但只想使用他们的接口而不是实现

### 要素

- AbstractFactory
- ConcreateFactory
- AbstractProduct
- ConcreteProduct
- Client

### 缺点

难以支持新种类产品的创建，如果要支持新的产品创建，则需要对所有实现类都跟随抽象工厂做修改。

解决方案，使用工厂方法（Factory Method）模式，通过传入希望得到的产品类型，具体的工厂实现类按照传入的类