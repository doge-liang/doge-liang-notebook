---
title: 多线程
date: 2022-07-13
tags: []
categories:
  - 程序设计语言
  - Java
  - 多线程
---

## 多线程

### CAS

**CAS**（Compare And Swap）：比较并替换，CAS 机制定义了三个基本的操作数：内存地址 V ，预期值 A ，要修改成值 B 。
当更新一个变量时，只有当地址 V 的变量为预期值 A 才将地址 V 中的值替换为值 B 。
考虑两个线程都在更新某个变量的场景：

1. 线程 1 想要将 V 出的值 10 增加 1 ，此时对于地址 V 变量的预期值为 10 ，要更新为 11；
2. 线程 1 执行更新操作时， CPU 被线程 2 抢占，地址 V 被抢先一步更新为 11 ；
3. 线程 1 开始执行更新操作时，**比较**地址 V 的值发现和预期值 10 不一样，更新失败；
4. 线程 1 重新获取地址 V 的值 11 ，要更新为新值 12 ，这个重试的操作被称为 **自旋**；
5. 这次线程 1 没有被抢占，**比较**地址 V 的值发现和预期值 11 相同，进行**交换**操作，将地址 V 的值替换为 12；

CAS 对于并发程度的估计是乐观的，所以让线程不断地重试之前的操作，分类上叫 **乐观锁**。
而 Synchronized 属于 **悲观锁** ，对并发程度的估计是悲观的，所以对资源的访问严防死守。

在 Java 中 Atomic 系列类和 Lock 系列类的底层实现都是使用 CAS 机制实现的。

#### 实现原理

以 `incrementAndGet()` 方法为例：

```java
public final int incrementAndGet() {
    for (;;) {
        int current = get();
        int next = current + 1;
        if (compareAndSet(current, next))
            return next;
    }
}
private volatile int value;
public final int get() {
    return value;
}
```

这段代码是一个无限循环，也叫做 **自旋** ，循环主要完成：

1. 获取当前值；
2. 对值进行 +1 操作，计算出目标值；
3. 进行 CAS 操作，如果成功则跳出循环，如果失败则重复上述步骤；

这里通过 `volatile` 保证获取的值是当前的最新值。

接下来看 `compareAndSet()` 的实现：

```JAVA
public final boolean compareAndSet(int expect, int update) {
  return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
}

private static final Usafe unsafe = Unsafe.getUnsafe();
private static final long valueOffset;

static {
  try {
    valueOffset = unsafe.objectFieldOffset(AtomicInteger.class.getDeclareField("value"));
  } catch(Exception ex) {
    throw new Error(ex);
  }
}
```

`compareAndSet()` 方法实现很简单，只有一行代码。涉及到两个对象，一个是 **unsafe** 一个是 **valueOffset** 。

**unsafe** 是 JVM 提供的后门，给 Java 提供了 **硬件级别的原子操作** 。
**valueOffset** 对象是通过 `unsafe.objectFieldOffset()` 方法得到的，代表的是 `AtomicInteger` 对象 value 成员变量在内存中的偏移量。可以简单理解为 value 变量的内存地址；

这里的 valueOffset 、 expect 、 update 分别代码 CAS 的内存地址 V 、 预期值 A 和新值 B 。正是 unsafe 提供的 `compareAndSwapInt()` 方法包括了这三个基本元素，保证了 Compare 和 Swap 操作的原子性。

##### CAS 的缺点

1. CPU 开销大，在并发程度高的时候，大量线程都在重复尝试更新变量，耗费了大量的时间 在空转；
2. 不能保证 **代码块** 的原子性，只能保证针对 **某个变量** 操作的原子性，而无法同时保证多个变量的操作是原子的，这时候就不得不使用 synchronized 了；
3. **ABA 问题** ，由于线程只关心最新的值是否为预期值，所以线程并不知道变量在 `compareAndSet()` 之前是否经历过从 A 变为 B 又变为 A 的过程，会直接通过检测，这在某些场景下会产生错误；为了解决这个问题，引入了版本号的机制，每次比较的时候还要加上版本号一起比较，当提交了修改之后，版本号 +1 ，这样便让 `compareAndSet()` 方法更确切地保证在更新之前值没有被更新过；

### 偏向锁

jdk 1.5 以前 Java 的并发问题都是使用 **Synchronized** 解决的，这种 **重量级锁** 依赖于操作系统的调度，需要频繁在用户态和内核态之间切换，效率不行；

后来出现了 CAS 使用，失败-重试机制，使加锁和释放锁的过程不需要上下文切换，竞争不激烈时有不错的性能。但是经过研究发现，大多数情况下，获得锁的都是同一个线程，即使是轻量级锁的方式获取，但还是会影响性能。
偏心锁在 CAS 的基础上，添加了了偏心机制，锁对象会记住线程的 ID ，当线程再次获取锁时，锁对象发现和上次的一样，就直接把锁给他。这种锁考虑的是只有一个线程进入临界区的情况。当有多个线程进入临界区时，为了提高效率，会被升级成 **轻量级锁** 也即 CAS ，如果竞争进一步加剧，那就会升级成 **重量级锁**。

偏向锁和轻量级锁都不会调用 **系统互斥量** （Mutex Lock），只是为了提升性能而多出的两种锁的状态，以便在不同场景下采取合适的锁。

> 互斥量：是保证关键指令的原子性的一种机制，是最简单的线程同步方法。互斥量往往处于两种状态之一：解锁和加锁，就像厕所格子间的门锁，多人前来上厕所时，先进去的人把门锁锁上了，后面的人看到门上的状态是红的，说明有人在用，只能排队等待。是 **操作系统级别** 的线程同步方式。

Java 对象的锁的信息是维护在 **对象头** 上的， Java 对象头由三部分构成：

1. MarkWord（对象锁信息维护在这里）
2. ClassMetaData Address
3. Array Length (如果是数组对象才会有)

![picture 3](../../../../../assets/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/457d78882154a8d0cbc9ef4829ce479dcf0ccb40f612d8473e26b72e7c4e9784.png)

从左到右，高位到低位，由于还有 GC 标志位，加上四个锁状态，至少需要 3 bit 来描述一个对象的锁状态，如上图所示。

虽然说 jdk 1.6 版本后，是默认开启偏向锁的，但是实际上，由于 Java 中大量的 `synchronized` 的使用，直接开启偏向锁，进入同步块竞争的时候，就需要有锁升级，会带来额外的性能损耗。因此， JVM 提供了延迟策略，程序启动后大约 4s 后才会开启偏向锁。

### happen-before 原则

Java 提供了三种方式保证程序执行结果的有序性：

1. `volatile` ；
2. `synchronized` ；
3. `Lock` ；

此外， Java 的内存模型具备天生的有序性，不需要任何的同步手段即可保证，这些规则又被叫做 **happens-before 原则**；

具体有：

1. 程序次序规则
2. 锁定规则
3. `volatile` 变量规则
4. 传递规则
5. 线程启动规则
6. 线程中断规则
7. 线程的终结规则
8. 对象的终结规则

**volatile 关键字具有保证顺序性的语义** 。
