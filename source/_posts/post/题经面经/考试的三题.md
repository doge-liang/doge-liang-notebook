---
title: 考试的三题
date: 2021-08-18
tags: [OJ考试]
categories: 
    - [题经面经]
---

## 考试的三题

### 子串相乘最大值

输入一个字符串（无前导零）将其分割为两个子串，计算子串相乘的最大值。

```java
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in, StandardCharsets.UTF_8.name());
        String numberStr = sc.next();
        sc.close();
        System.out.println(getMultiValue(numberStr));
    }

    static int getMultiValue(String numberStr) {
        ArrayList<Integer> resList = new ArrayList<>();
        int left;
        int right;
        int len = numberStr.length();
        for (int i = 1; i < numberStr.length(); i++) {
            left = Integer.parseInt(numberStr.substring(0, i));
            right = Integer.parseInt(numberStr.substring(i, len));
            resList.add(left * right);
        }
        return resList.stream().max(Integer::compareTo).orElse(0);
    }
}
```

### 寻找最大比特子串

输入一个比特流（01串）和一个目标比特，有一次反转非目标比特的机会，宣召最长的比特子串。

```java
public class Main {

    public static void main(String[] args) {
        Scanner cin = new Scanner(System.in, StandardCharsets.UTF_8.name());
        int target = cin.nextInt();
        int length = cin.nextInt();
        int[] bits = new int[length];
        for (int i = 0; i < length; i++) {
            bits[i] = cin.nextInt();
        }
        cin.close();

        System.out.println(findMaxConsecutiveBits(target, bits));
    }

    static int findMaxConsecutiveBits(int target, int[] bits) {
        // 只有全为 target 值的才不用替换
        boolean isAllMatch = Arrays.stream(bits).allMatch((value) -> {
            return value == target;
        });
        if (isAllMatch) {
            return bits.length;
        }
        // 若不全为 target ，则遍历数组，数 target 子串的长度，将所有可能的长度存入数组中，再在数组中找最大值
        // 每一个非 target 的位都有一次机会变成 target ，机会用完了，又遇到非 target 就清空 counter 存入数组，
        // 回到上一次丢失 chance 的下一位继续数
        int chance = 1;
        int checkpoint = 0;
        int counter = 0;
        ArrayList<Integer> resList = new ArrayList<>();
        for (int i = 0; i < bits.length; i++) {
            if (bits[i] == target) {
                counter++;
            }
            if (bits[i] != target) {
                if (chance == 1) {
                    chance = 0;
                    checkpoint = i;
                    counter++;
                } else {
                    resList.add(counter);
                    counter = 0;
                    chance = 1;
                    i = checkpoint;
                }
            }
        }
        resList.add(counter);
        return resList.stream().max(Integer::compareTo).get();
    }
}
```

### 停车记录筛选

输入记录有 `停车时间` `车牌号码` `停车小时数` ，输入记录有重复的，按照以下优先级筛选。

- 停车时长长的优先
- 停车次数（记录条数）多的优先
- 按车牌号的字典顺序降序

```java
public class Main {

    static class Record {
        String name;
        String date;
        int time;

        Record(String name, String date, int time) {
            this.name = name;
            this.date = date;
            this.time = time;
        }
    }

    static class Car {
        String name;
        int times;
        int totalTime;

        Car(String name, int times, int totalTime) {
            this.name = name;
            this.times = times;
            this.totalTime = totalTime;
        }
    }

    private static List<String> getTopCars(int month, List<Record> records) {
        // 数字月份转换成字符串方便构建正则
        String monthStr = (month < 10) ? "0" + month : "" + month;
        // 排除非指定月份的记录
        records.removeIf(record -> !record.date.matches(".*-" + monthStr + "-.*"));
        // 计算停留时长
        Map<String, Integer> timeMap = new HashMap<>();
        for (Record record : records) {
            timeMap.put(record.name, 0);
        }
        for (Record record : records) {
            timeMap.replace(record.name, timeMap.get(record.name) + record.time);
        }
        // 计算停留次数
        Map<String, Integer> timesMap = new HashMap<>();
        for (Record record : records) {
            timesMap.put(record.name, 0);
        }
        for (Record record : records) {
            timesMap.put(record.name, timesMap.get(record.name) + 1);
        }
        ArrayList<Car> cars = new ArrayList<>();
        for (String name : timeMap.keySet()) {
            Car car = new Car(name, timesMap.get(name), timeMap.get(name));
            cars.add(car);
        }
        cars.sort((o1, o2) -> {
            if (o1.totalTime > o2.totalTime) {
                return -1;
            }
            if (o1.totalTime < o2.totalTime) {
                return 1;
            }
            if (o1.times > o2.times) {
                return -1;
            }
            if (o1.times < o2.times) {
                return 1;
            }
            Integer num1 = Integer.parseInt(o1.name.substring(1));
            Integer num2 = Integer.parseInt(o2.name.substring(1));
            return num1.compareTo(num2);
        });
        ArrayList<String> resList = new ArrayList<>();
        for (Car car : cars) {
            resList.add(car.name);
        }
        if (resList.size() > 5) {
            return resList.subList(0, 5);
        }
        return resList;
    }

    public static void main(String[] args) {
        List<Record> records = new ArrayList<>();
        Scanner scanner = new Scanner(System.in, StandardCharsets.UTF_8.name());
        int month = scanner.nextInt();
        int num = scanner.nextInt();
        for (int i = 0; i < num; i++) {
            Record record = new Record(scanner.next(), scanner.next(), scanner.nextInt());
            records.add(record);
        }
        System.out.print(String.join(" ", getTopCars(month, records)));
    }
}
```